<?php declare(strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Logging\OpenTestReporting;

use const DIRECTORY_SEPARATOR;
use const PHP_OS_FAMILY;
use function array_pop;
use function assert;
use function count;
use function fclose;
use function function_exists;
use function getenv;
use function gethostname;
use function is_array;
use function is_resource;
use function php_uname;
use function posix_geteuid;
use function posix_getpwuid;
use function preg_split;
use function proc_close;
use function proc_open;
use function str_contains;
use function str_replace;
use function str_starts_with;
use function stream_get_contents;
use function trim;
use DateTimeImmutable;
use DateTimeZone;
use PHPUnit\Event\EventFacadeIsSealedException;
use PHPUnit\Event\Facade;
use PHPUnit\Event\Test\BeforeTestMethodErrored;
use PHPUnit\Event\Test\Prepared as TestStarted;
use PHPUnit\Event\TestSuite\Started as TestSuiteStarted;
use PHPUnit\Event\UnknownSubscriberTypeException;
use PHPUnit\TextUI\Output\Printer;
use XMLWriter;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class OtrXmlLogger
{
    private readonly Printer $printer;
    private XMLWriter $writer;

    /**
     * @var non-negative-int
     */
    private int $idSequence = 0;

    /**
     * @var ?positive-int
     */
    private ?int $parentId = null;

    /**
     * @var list<positive-int>
     */
    private array $parentIdStack = [];

    /**
     * @var ?positive-int
     */
    private ?int $testId = null;

    /**
     * @var 'ABORTED'|'ERRORED'|'FAILED'|'SKIPPED'|'SUCCESSFUL'
     */
    private string $result      = 'SUCCESSFUL';
    private bool $parentErrored = false;

    /**
     * @throws EventFacadeIsSealedException
     * @throws UnknownSubscriberTypeException
     */
    public function __construct(Printer $printer, Facade $facade)
    {
        $this->printer = $printer;

        $this->registerSubscribers($facade);
    }

    public function flush(): void
    {
        assert($this->writer instanceof XMLWriter);

        $this->writer->endElement();
        $this->writer->endDocument();

        $this->printer->print($this->writer->outputMemory());
        $this->printer->flush();
    }

    public function testRunnerStarted(): void
    {
        $gitInformation = $this->gitInformation();

        $this->writer = new XMLWriter;

        $this->writer->openMemory();
        $this->writer->setIndent(true);
        $this->writer->startDocument();

        $this->writer->startElement('e:events');
        $this->writer->writeAttribute('xmlns', 'https://schemas.opentest4j.org/reporting/core/0.2.0');
        $this->writer->writeAttribute('xmlns:e', 'https://schemas.opentest4j.org/reporting/events/0.2.0');

        if ($gitInformation !== false) {
            $this->writer->writeAttribute('xmlns:e', 'https://schemas.opentest4j.org/reporting/git/0.2.0');
        }

        $this->writer->startElement('infrastructure');
        $this->writer->writeElement('hostName', $this->hostName());
        $this->writer->writeElement('userName', $this->userName());
        $this->writer->writeElement('operatingSystem', php_uname());

        if ($gitInformation !== false) {
            $this->writer->startElement('git:repository');
            $this->writer->writeAttribute('originUrl', $gitInformation['originUrl']);
            $this->writer->endElement();

            $this->writer->writeElement('git:branch', $gitInformation['branch']);
            $this->writer->writeElement('git:commit', $gitInformation['commit']);

            $this->writer->startElement('git:status');
            $this->writer->writeAttribute('clean', $gitInformation['clean'] === true ? 'true' : 'false');
            $this->writer->writeCdata($gitInformation['status']);
            $this->writer->endElement();
        }

        $this->writer->endElement();
    }

    public function testSuiteStarted(TestSuiteStarted $event): void
    {
        $id                    = ++$this->idSequence;
        $this->parentId        = $id;
        $this->parentIdStack[] = $id;

        $this->writer->startElement('e:started');
        $this->writer->writeAttribute('id', (string) $id);
        $this->writer->writeAttribute('name', $event->testSuite()->name());
        $this->writer->writeAttribute('time', $this->timestamp());
        $this->writer->endElement();
    }

    public function parentErrored(): void
    {
        $this->parentErrored = true;
    }

    public function beforeTestMethodErrored(BeforeTestMethodErrored $event): void
    {
        $id = ++$this->idSequence;

        $this->writeTestStarted(
            $id,
            $this->parentId,
            $event->test()->id(),
        );

        $this->writeTestFinished($id, 'ERRORED');
    }

    public function testPrepared(TestStarted $event): void
    {
        $id           = ++$this->idSequence;
        $this->testId = $id;

        $this->writeTestStarted(
            $id,
            $this->parentId,
            $event->test()->id(),
        );
    }

    public function testFailed(): void
    {
        $this->result = 'FAILED';
    }

    public function testErrored(): void
    {
        $this->result = 'ERRORED';
    }

    public function testSkipped(): void
    {
        $this->result = 'SKIPPED';
    }

    public function testAborted(): void
    {
        $this->result = 'ABORTED';
    }

    public function testFinished(): void
    {
        assert($this->testId !== null);

        $this->writeTestFinished($this->testId, $this->result);

        $this->testId = null;
        $this->result = 'SUCCESSFUL';
    }

    public function testSuiteFinished(): void
    {
        $this->writer->startElement('e:finished');
        $this->writer->writeAttribute('id', (string) $this->parentId);
        $this->writer->writeAttribute('time', $this->timestamp());

        if ($this->parentErrored) {
            $this->writer->startElement('result');
            $this->writer->writeAttribute('status', 'ERRORED');
            $this->writer->endElement();
        }

        $this->writer->endElement();

        array_pop($this->parentIdStack);

        if ($this->parentIdStack !== []) {
            $this->parentId = $this->parentIdStack[count($this->parentIdStack) - 1];

            return;
        }

        $this->parentId = null;
    }

    /**
     * @throws EventFacadeIsSealedException
     * @throws UnknownSubscriberTypeException
     */
    private function registerSubscribers(Facade $facade): void
    {
        $facade->registerSubscribers(
            new TestRunnerStartedSubscriber($this),
            new TestSuiteStartedSubscriber($this),
            new BeforeFirstTestMethodErroredSubscriber($this),
            new BeforeTestMethodErroredSubscriber($this),
            new AfterLastTestMethodErroredSubscriber($this),
            new TestPreparedSubscriber($this),
            new TestAbortedSubscriber($this),
            new TestErroredSubscriber($this),
            new TestFailedSubscriber($this),
            new TestSkippedSubscriber($this),
            new TestFinishedSubscriber($this),
            new TestSuiteFinishedSubscriber($this),
            new TestRunnerFinishedSubscriber($this),
        );
    }

    /**
     * @return non-empty-string
     */
    private function timestamp(): string
    {
        return (new DateTimeImmutable('now', new DateTimeZone('UTC')))->format('Y-m-d\TH:i:s.u\Z');
    }

    /**
     * @return non-empty-string
     */
    private function hostName(): string
    {
        $candidate = gethostname();

        if ($candidate === false) {
            return 'unknown';
        }

        $candidate = trim($candidate);

        if ($candidate === '') {
            return 'unknown';
        }

        return $candidate;
    }

    /**
     * @return non-empty-string
     */
    private function userName(): string
    {
        if (function_exists('posix_getpwuid') && function_exists('posix_geteuid')) {
            $candidate = trim(posix_getpwuid(posix_geteuid())['name']);
        } elseif (PHP_OS_FAMILY === 'Windows') {
            $candidate = trim((string) getenv('USERNAME'));
        }

        if (!isset($candidate) || $candidate === '') {
            return 'unknown';
        }

        return $candidate;
    }

    /**
     * @param positive-int     $id
     * @param ?positive-int    $parentId
     * @param non-empty-string $name
     */
    private function writeTestStarted(int $id, ?int $parentId, string $name): void
    {
        $this->writer->startElement('e:started');
        $this->writer->writeAttribute('id', (string) $id);

        if ($parentId !== null) {
            $this->writer->writeAttribute('parent', (string) $parentId);
        }

        $this->writer->writeAttribute('name', $name);
        $this->writer->writeAttribute('time', $this->timestamp());
        $this->writer->endElement();
    }

    /**
     * @param positive-int                                        $id
     * @param 'ABORTED'|'ERRORED'|'FAILED'|'SKIPPED'|'SUCCESSFUL' $status
     */
    private function writeTestFinished(int $id, string $status): void
    {
        $this->writer->startElement('e:finished');
        $this->writer->writeAttribute('id', (string) $id);
        $this->writer->writeAttribute('time', $this->timestamp());
        $this->writer->startElement('result');
        $this->writer->writeAttribute('status', $status);
        $this->writer->endElement();
        $this->writer->endElement();
    }

    /**
     * @return array{originUrl: non-empty-string, branch: non-empty-string, commit: non-empty-string, clean: bool, status: string}|false
     */
    private function gitInformation(): array|false
    {
        $buffer = $this->executeGitCommand('remote show -n');

        if ($buffer === false) {
            return false;
        }

        if (!str_contains($buffer, 'origin')) {
            return false;
        }

        $buffer = $this->executeGitCommand('remote show -n origin');

        if ($buffer === false) {
            return false;
        }

        $lines = preg_split("/\r\n|\n|\r/", $buffer);

        if (!isset($lines[1]) || !str_starts_with($lines[1], '  Fetch URL: ')) {
            return false;
        }

        $originUrl = trim(str_replace('  Fetch URL: ', '', $lines[1]));

        $branch = $this->executeGitCommand('symbolic-ref --short HEAD');

        if ($branch === false) {
            return false;
        }

        $commit = $this->executeGitCommand('rev-parse HEAD');

        if ($commit === false) {
            return false;
        }

        $status = $this->executeGitCommand('status --porcelain');

        if ($status === false) {
            return false;
        }

        return [
            'originUrl' => $originUrl,
            'branch'    => $branch,
            'commit'    => $commit,
            'clean'     => $status === '',
            'status'    => $status,
        ];
    }

    /**
     * @return false|non-empty-string
     */
    private function executeGitCommand(string $command): false|string
    {
        $command = 'git ' . $command;

        if (DIRECTORY_SEPARATOR === '/') {
            $command = 'LC_ALL=en_US.UTF-8 ' . $command;
        }

        $process = @proc_open(
            $command,
            [
                1 => ['pipe', 'w'],
                2 => ['pipe', 'w'],
            ],
            $pipes,
        );

        if (!is_resource($process)) {
            return false;
        }

        assert(is_array($pipes));
        assert(isset($pipes[1]) && is_resource($pipes[1]));
        assert(isset($pipes[2]) && is_resource($pipes[2]));

        $result = trim((string) stream_get_contents($pipes[1]));

        fclose($pipes[1]);
        fclose($pipes[2]);

        $returnCode = proc_close($process);

        if ($returnCode !== 0) {
            return false;
        }

        return $result;
    }
}
